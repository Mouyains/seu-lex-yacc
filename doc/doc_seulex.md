# seulex 说明文档

## 如何使用

- 从 [项目GitHub仓库](https://github.com/z0gSh1u/seu-lex-yacc) 下载或 clone 下整个仓库。

- seulex 依赖于 Node.js 运行时，因此你需要预先安装 [Node.js](https://nodejs.org/zh-cn/)。然后，在项目根目录下执行 `npm install` 来安装依赖。

- 现在便可以使用 seulex 的 CLI 工具了：

  ```powershell
  node <path_to_project>/dist/seulex/cli.js <lex_file> <options>
  ```

  执行上述命令后，会在当前目录下生成 yy.seulex.c 文件，即为词法分析器的 C 源代码。

  ```
  [ Running... ]
  [ Parsing .l file... ]
  [ Building NFA... ]
  [ Building DFA... ]
  [ Generating code... ]
  [ Main work done! Start post-processing... ]
  [ All work done! ]
  [ Time consumed: 7035 ms. ]
  ```

  可用的 options 包括：

  - -p：格式化生成的 C 代码
  - -c：生成后自动调用 GCC 编译，如果要给 GCC 传递参数，可使用`"-c <params>"`形式
  - -v：可视化最终的 DFA


## Can I use...

- seulex 支持下列 lex 特性：
  - 正则表达式五大元符号：`? + * | . `（0或1次，1次或以上，0次或以上，或，任意字符）
  - 正则表达式范围与范围补：`[A-Za-z0-9_] [^"]`
  - 正则别名定义
  - 正则定义时，引号内保留原样
  - 可以使用范围型转义字符\d（`[0-9]`）和\s（`[ \t\r\n]`）
  - 最长匹配原则，即使用当前位置能匹配最长串的正则。如果有等长的情况，越早出现的正则优先级越高
  - 必须要在用户程序段为 yyin 输入流赋值
  - 可在用户程序段重定向 yyout 输出流。如果不，则默认输出到 stdout
  - 使用变量 yylineno 可以获取当前行号
  - 使用变量 yyleng 可以获取当前词法单元长度
  - 使用变量 yytext 可以获取当前匹配的字符串
  - 可以使用 yyless、yymore 来回退或补进词法单元
  - 可以使用 yywrap
  - 可以使用 ECHO 将 yytext 输出到 yyout
  - 持续调用 yylex 就可以进行逐词的词法分析，返回 0 表示不再有可产生的词法单元，返回 -1 表示出现错误
- seulex 不支持下列 lex 特性：
  - 正则表达式不支持 {n, m} 等形式的出现次数限定
  - 不支持前瞻、后瞻正则表达式
  - 不支持 REJECT
- 以下信息可能对你编写 lex 源文件有帮助：
  - seulex 会自动引入 `<stdio.h> / <stdlib.h> / <string.h>`
  - 尽量不使用下划线开头的变量，因为可能与 seulex 预置变量冲突

## 处理流程

本部分将介绍 seulex 的实现细节。

### lex 源文件解析

相关代码为 LexParser.ts。

本步骤将 lex 源文件的四部分（直接复制部分、正则别名部分、正则-动作部分、用户代码部分）分割出来，进行解析，并展开正则别名，最后填充 _regexActionMap（正则→动作映射）供后续使用。

- 进行了严格的校验，对格式不合格的 lex 源文件、重定义的正则或别名等等，均会报错

- 正则别名部分可以分布在直接复制部分之前，也可以分布在正则-动作部分之前，均会被收集

- 正则-动作部分支持各种写法，如：

  ```lex
  {title} { lhs = strdup(yytext); return (TITLE); } // 多句使用大括号，可以换行、可以不换行…
  a+b?  return 0x05; // 单句可以不用大括号
  \"[^"]\" ; // 啥都不做可以只写一个分号
  ```

在解析正则-动作部分时，没有借助正则表达式来简化代码（在一个玩正则表达式的程序里用正则表达式，总感觉有些取巧），而是维护了一系列表示“是否…”的状态变量以进行正确的解析。这实际上是手工维护了一个状态机，也印证了不使用正则表达式来处理文本的可能性。但过程繁冗复杂，容易出错。因此，我们在后面的程序中借助了正则表达式来对代码进行一定简化。

### 正则表达式处理

相关代码为 Regex.ts。

本步骤按如下工作流处理 LexParser 送来的 _regexActionMap 中的正则表达式：

- 展开表示多字符的转义，如 \d 和 \s，转换为 [0-9] 等方框范围形式

- 展开方框范围，重构成括号或的形式，如 [a-cf] 转为 (a|b|c|f)

- 进行“隐式”加“点”处理，恢复连缀关系。为了避免字符冲突，使用数组而非具体字符来表达连缀关系：

  ```
  abc[a-bA-B0-2_]      ->      ['a', 'b', 'c', '(a|b|A|B|0|1|2|_)']
  ```

- 利用栈将中缀正则表达式转换为后缀正则表达式

上面的 1~3 步要考虑：

- 在真正的（非转义的）引号内的字符，要直接保留原样
- 转义的字符是什么（`\\n`和`\n`是不同的，不能见到反斜杠就把它和下一个字符粘在一起）
- 方框范围报错（如`c-a`式范围）、去重、是否需要生成非打印 ASCII 字符等等

第 4 步要考虑：

- 由于去掉了引号，引号内的特殊字符要做转义
- 后缀正则表达式中的“加点”关系怎么表示

### NFA 相关

相关代码为 NFA.ts。

本步骤主要从后缀形式的正则表达式生成对应的 NFA，最后将一系列 NFA 进行并联。

将后缀正则表达式转为 NFA 步骤要点是：

- 由于上一步对引号内容做了保留原样和拆除引号的处理，这一步就不用考虑引号问题了
- 对二元运算符，每次弹出两个 NFA 进行运算后放回，如或符号`|`，需要并联两个 NFA
- 对一元运算符，每次弹出一个 NFA 进行运算后放回，如正闭包`A+`（相当于`AA*`），需要串联 A 和 A 作 Kleene 闭包后的结果
- 对于普通的字符，构造一个形如 `0->char->[1]` 的原子 NFA 即可
- 接收状态需要与它对应的动作进行绑定，即填充 _acceptActionMap（接收状态→动作代码映射），注意此步动作代码还要带上出现次序（优先级），在下一步 NFA 的确定化中要使用
- 为了更高效地表示边上的字母，我们使用了字母表，用字符在表的下标表示边上的字母，特别地，-1 表示 ε（空串），-2 表示 ANY （任意字符）

将 LexParser 送来的正则表达式均转为 NFA 后，进行并联，形成形如这样的大 NFA，送下层：

```
            ε  NFA1
new_start <-   ...       // 注意尾部不要收束
            ε  NFAn
```

### DFA 相关

相关代码为 DFA.ts。

本步骤主要对 NFA 进行确定化、最小化。

对 NFA 进行确定化的要点是：

- 因为需要反复求取 epsilon 闭包，所以必须保证该段程序正确无误
- 处理表示任意字符的 ANY 边时，拆分为已有迁移的字符构成的边和其余字母构成的边。为了避免将 ANY 展开为字符全集（会成吨地增加状态数，降低 DFA 构造速度），我们引入了巧妙的 OTHER 边来表示其余字母构成的边
- 一个 DFA 接收状态可能包括多个 NFA 接收状态，这些接收状态对应的动作代码有可能是不同的，此时需要借助“先定义优先”的优先级规则进行排除

对 DFA 进行最小化的要点是：

- 对于有 ANY 边的 DFA，由于每个 OTHER 边包含的字符是不同的，因此很难进行最小化
- 动作代码需要跟着状态一起走，并且有可能需要根据优先级排除动作代码冲突

### 代码生成相关

相关代码为 CodeGenerator.ts。

本步骤主要根据 DFA 生成最终的词法分析器 C 代码。该步骤的工作流如下：

- 复制 lex 源文件的直接复制部分
- 生成 seulex 的预置变量
- 生成状态转移矩阵：如 `mat[i][k]` 表示在 `i` 状态收到字符 `k` 后转移到的状态
- 生成接收态-case代号对应表，用于转移到动作代码
- 生成 yylex 函数，注意在此要实现最长匹配要求，以及利用 switch-case 引入动作代码。实现最长匹配要求的方法有很多，我们采用记忆当前最长匹配接收态的方法来实现
- 生成 yyless、yymore 函数
- 复制 lex 源文件的用户代码段

### 后处理

后处理主要包括生成的 C 代码的美化、GCC 的自动调用、DFA 的可视化等增强需求。

## 增强

seulex 提供了许多增强功能，包括：

- 自动 GCC 调用

- C 代码美化

- 自动机可视化

  利用 -v 参数，或调用 `visualizeFA(fa: FA)` 函数即可。过大规模的自动机无法可视化

- C 字符串库

  C 语言处理字符串的体验很糟，在 `<path_to_project>/enhance/seustr.h` 中提供了一套简单好用的 C 字符串库，帮助你实现各种常用功能

## 开发与贡献

seulex 作为一个课程项目，仓促开发，功能有限，程序的正确性也不能保证。所以欢迎你为 seulex 贡献代码！

- 鼓励在 `test` 目录下使用 TypeScript 撰写单元测试
- 项目使用 Travis CI 进行持续集成，你提交的代码会经过 ESLint 和 Jest 的检查

## 其他

如果你是东南大学修习相关课程的学生，并且认可本项目，那我们感到非常荣幸！欢迎你从我们的项目中参考、学习，期待你做出更好的课程设计作业。但你也需要了解，虽然项目以 MIT License 分发，但你还需要遵守下面的条例：

>**《东南大学学生学术道德规范条例》**
>
>第九条    有下列行为之一的，应当被认定为违反学术道德的行为：
>
>1、侵占、抄袭、剽窃他人学术成果（包括论文成果、技术报告、软件程序和研究数据及课程论文等）；