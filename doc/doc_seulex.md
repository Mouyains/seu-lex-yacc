# seulex 说明文档

## 如何使用

- 从 [项目GitHub仓库](https://github.com/z0gSh1u/seu-lex-yacc) 下载或 clone 下整个仓库。

- seulex 依赖于 Node.js 运行时，因此你需要预先安装 [Node.js](https://nodejs.org/zh-cn/)。然后，在项目根目录下执行 `npm install` 来安装依赖库。

- 现在便可以使用 seulex 的 CLI 工具了：

  ```powershell
  node <path_to_project>/dist/seulex/cli.js <lex_file> <options>
  ```

  执行上述命令后，会在当前目录下生成 yy.seulex.c 文件，即为词法分析器的 C 源代码。

  ```
  [ Running... ]
  [ Parsing .l file... ]
  [ Building NFA... ]
  [ Building DFA... ]
  [ Generating code... ]
  [ Main work done! Start post-processing... ]
  [ All work done! ]
  [ Time consumed: 7035 ms. ]
  ```

  可用的 options 包括：

  - -p：格式化生成的 C 代码
  - -c：生成后自动调用 GCC 编译，如果要给 GCC 传递参数，可使用`"-c <params>"`形式
  - -v：可视化最终的 DFA

- 如果你有需要，还可以在安装 Python 3 后使用 GUI 界面：

  ```powershell
  python <path_to_project>/bin/seulexGUI.py
  ```

## 注意事项

- seulex 对 lex 源文件有一定限制，主要包括：
  - 暂不支持 {n, m} 等限定出现次数的正则表达式
  - 暂不支持 [^] 取补形式的正则表达式
  - 不支持前瞻、后瞻正则表达式
  - 表示空格必须使用引号引起（`" "`）
  - 不支持 yyless、yymore、REJECT
- 以下信息可能对你编写 lex 源文件有帮助：
  - seulex 会自动引入 `<stdio.h> / <stdlib.h> / <string.h>`
  - seulex 采用最长匹配原则，即使用当前位置能匹配最长串的正则。如果有等长的情况，越早出现的正则优先级越高
  - 必须要在用户程序段为 yyin 输入流赋值
  - 如果有需要，可在用户程序段重定向 yyout 输出流，如果不，则默认输出到 stdout
  - 持续调用 yylex 就可以进行逐词的词法分析，如果返回 0 则表示不再有可产生的词法单元，返回 -1 表示出现了错误
  - 使用变量 yylineno 可以获取当前行号
  - 使用变量 yyleng 可以获取当前词法单元长度
  - 使用变量 yytext 可以获取当前匹配的字符串
  - 使用宏 ECHO; 可以将 yytext 输出到 yyout
  - 尽量不使用下划线开头的变量，因为可能与 seulex 预置变量冲突

## 处理流程

本部分将介绍 seulex 的实现细节。

### lex 源文件解析

相关代码为 LexParser.ts。

本步骤将 lex 源文件的四部分（直接复制部分、正则别名部分、正则-动作部分、用户代码部分）分割出来，进行解析，并展开正则别名，最后填充 _regexActionMap（正则→动作映射）供后续使用。

- 进行了严格的校验，对格式不合格的 lex 源文件、重定义的正则或别名等等，均会报错

- 正则别名部分可以分布在直接复制部分之前，也可以分布在正则-动作部分之前，均会被收集

- 正则-动作部分支持各种写法，如：

  ```
  {title} {
    yylval = strdup(yytext + 2); return (TITLE); } // 多句使用大括号，可以换行、可以不换行…
  a+b?  return 0x05; // 单句可以不用大括号
  (\r|\n) ; // 啥都不做可以只写一个分号
  ```

### 正则表达式处理

相关代码为 Regex.ts。

本步骤按如下工作流处理 LexParser 送来的 _regexActionMap 中的正则表达式：

- 展开表示多字符的转义，如\d和\s，转换为 [0-9] 等方框范围形式
- 展开方框范围，重构成括号或形式，如 [a-cf] 转为 (a|b|c|f)
- 进行隐式加“点”处理，恢复连缀关系。为了避免冲突，使用数组而非真实的字符来表达连缀关系
- 利用栈将中缀正则表达式转换为后缀正则表达式

需要注意的是，上面的所有步骤都需要考虑：如果在引号内，则保留原样不做处理；是真正的引号还是转义的引号；引号是否配对，等一系列问题。

### NFA 相关

相关代码为 NFA.ts。

本步骤主要从正则表达式生成对应的 NFA，最后将一系列 NFA 进行并联。

将后缀正则表达式转为 NFA 步骤要点是：

- 妥善处理转义字符，不应打散
- 由于正则表达式处理阶段对引号内内容做了保留原样的处理，因此这一步就不用考虑引号问题了
- 对二元运算符，每次弹出两个 NFA 进行运算后放回，如或符号`|`，需要并联两个 NFA
- 对一元运算符，每次弹出一个 NFA 进行运算后放回，如正闭包`A+`（相当于`AA*`），需要串联 A 和 A 作 Kleene 闭包后的结果
- 对于普通的字符，构造一个形如 `0->char->[1]` 的原子 NFA 即可

将 LexParser 送来的正则表达式均转为 NFA 后，进行并联，形成形如这样的大 NFA：

```
            ε  NFA1
new_start <-   ...
            ε  NFAn
```

一些其他的实现细节是：

- 接收状态需要与它对应的动作进行绑定，即填充 _acceptActionMap（接收状态→动作代码映射）
- 为了更高效地表示边上的字母，使用字母表的形式，用字符在字母表的下标表示边上的字母，特别地，-1 表示 ε（空串），-2 表示 ANY （任意字符）

### DFA 相关

相关代码为 DFA.ts。

本步骤主要对 NFA 进行确定化、最小化。

对 NFA 进行确定化的要点是：

- 因为需要反复求取 epsilon 闭包，所以必须保证该段正确无误
- 需要对 ANY 边进行处理，主要是拆分为已有迁移的字母集合边和其余字母集合边。为了避免将 ANY 展开为字符全集（会成吨地增加状态数），使用了 OTHER 边进行表示
- 一个 DFA 接收状态可能包括多个 NFA 接收状态，这些接收状态对应的动作代码是有可能不同的，此时需要借助“先定义优先”的优先级规则进行排除

对 DFA 进行最小化的要点是：

- 对于有 ANY 边的 DFA，由于每个 OTHER 边包含的字符是不同的，因此很难进行最小化
- 动作代码需要跟着状态一起走，并且有可能需要根据优先级排除动作代码冲突

### 代码生成相关

相关代码为 CodeGenerator.ts。

本步骤主要根据 DFA 生成最终的词法分析器 C 代码。该步骤的工作流如下：

- 复制 lex 源文件的直接复制部分
- 生成 seulex 的预置变量
- 生成状态转移矩阵：如 `mat[i][k]` 表示在 `i` 状态收到字符 `k` 后转移到的状态
- 生成接收态-case对应表
- 生成 yylex 函数，注意在此实现最长匹配要求，以及利用 switch-case 引入动作代码
- 复制 lex 源文件的用户代码段

### 后处理

整条工作流在 cli.ts 中进行整合，后处理过程也在此体现。

## 增强

seulex 提供了许多增强功能，包括：

- GUI 版本

  如果你不习惯使用 CLI 工具，则可运行 `python <path_to_project>/bin/seulexGUI.py` 唤起 GUI 版本

- 自动 GCC 调用

- C 代码美化

- 自动机可视化

  利用 -v 参数，或调用 `visualizeFA(fa: FA)` 函数即可。过大规模的自动机无法可视化

- C 字符串库

  C 语言处理字符串的体验很糟，在 `<path_to_project>/enhance/seustr.h` 中提供了一套简单好用的 C 字符串库，帮助你实现各种常用功能

## 开发与贡献

seulex 作为一个课程项目，仓促开发，功能有限，正确性也不敢完全保证。欢迎你为 seulex 贡献代码！

- 鼓励在 `test` 目录下使用 TypeScript 撰写单元测试
- 项目使用 Travis CI 进行持续集成，你提交的代码会经过 eslint 和 jest 的检查

## 其他

如果你是东南大学修习相关课程的学生，并且认可本项目，那我们感到非常荣幸！欢迎你从我们的项目中参考、学习，期待你做出更好的课程设计作业。但你也需要了解，虽然项目以 MIT License 分发，但你还需要遵守下面的条例：

>**《东南大学学生学术道德规范条例》**
>
>第九条    有下列行为之一的，应当被认定为违反学术道德的行为：
>
>1、侵占、抄袭、剽窃他人学术成果（包括论文成果、技术报告、软件程序和研究数据及课程论文等）；