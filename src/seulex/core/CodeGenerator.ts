import { LexParser } from './LexParser'
import { DFA } from './DFA'
import { SpAlpha } from './FA'

/**
 * 根据.l文件解析器和最终DFA生成C代码
 */
export function generateCode(lexParser: LexParser, dfa: DFA) {
  /**
   * 生成状态转移矩阵
   */
  function genTransformMatrix() {
    // 128是ASCII码的数量，mat[i][k]表示在i状态收到k字符后转移到的状态
    let res = `
    const int _seulex_transfrom_matrix[${dfa.states.length}][128] = {
    `
    for (let i = 0; i < dfa.transformAdjList.length; i++) {
      let targets = Array(128).fill(-1) // -1表示没有此转移
      if (dfa.transformAdjList[i].every((t) => t.alpha !== SpAlpha.OTHER)) {
        for (let transform of dfa.transformAdjList[i]) {
          // TODO: DFA的字母表是不是一定不含[any]？是的话删去本TODO。
          targets[dfa.alphabet[transform.alpha].charCodeAt(0)] =
            transform.target
        }
      } else {
        // TODO: 请处理有Other情况的转移
      }
      res += targets.join(',') + ','
    }
    res = res.substring(0, res.length - 1) + '};' // 去掉多余的逗号
    return res
  }
  /**
   * 生成各接收态下的动作
   */
  function genActions() {
    let res = `
    switch (???) {
    `
    // TODO: 龟龟，怎么把动作和接收态对应起来？？？
    res += `case <接收状态编号>:`
    res += `<动作们>`
    res += `break;`
    // ...
    res += `
    default:
      break;
    }`
    return res
  }
  let finalCode = ''
  // lex预置变量
  finalCode += `
    //
    // Lexer generated by seulex
    // Visit github.com/z0gSh1u/seu-lex-yacc
    //
    // ========== seulex generation start ==========
    #define YYSTYPE char*
    int yylineno = 1;
    int yyleng = 0;
    char* yytext = new char[1024];
    FILE yyin;
    YYSTYPE yylval;
    // ========== seulex generation end ==========
  `
  // 直接复制部分
  finalCode += lexParser.copyPart
  // 状态转移相关
  finalCode += `
  // ========== seulex generation start ==========
  ${genTransformMatrix()}
  ${genActions()}
  // ========== seulex generation end ==========
  `
  // TODO: 生成yylex函数
  // 用户定义代码段部分
  finalCode = lexParser.cCodePart
  return finalCode
}
