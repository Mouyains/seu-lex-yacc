/* eslint-disable @typescript-eslint/no-use-before-define */
import { YaccParser } from './YaccParser'
import { LR1Analyzer } from './LR1'

/**
 * 生成Token编号供Lex使用
 */
export function generateYTABH(yaccParser: YaccParser) {
  function _generateTokenId() {
    let res = ``
    for (let i = 0; i < yaccParser.tokenDecl.length; i++)
      res += `#define ${yaccParser.tokenDecl[i]} ${i + 1}\n`
    return res
  }
  let res = `
  #ifndef Y_TAB_H_
  #define Y_TAB_H_
  ${_generateTokenId()}
  #endif
  `
  return res
}

/**
 * 生成语法分析器
 */
export function generateYTABC(yaccParser: YaccParser, analyzer: LR1Analyzer) {
  function _generateStructs() {
    return `
    struct _seulex_stack {
      struct _seulex_node* head;
      int size;
    }
    `
  }

  let finalCode = `  
  // ===========================================
  // |  YTABC generated by seuyacc             |
  // |  Visit github.com/z0gSh1u/seu-lex-yacc  |
  // ===========================================
  #define DEBUG_MODE 0
  // * ============== copyPart ================
  `
  finalCode += yaccParser.copyPart // 用户之间复制部分
  finalCode += `
  // * ========== seuyacc generation ============
  `
  finalCode += generateYTABH(yaccParser)
  finalCode += genPresetContent()
}

function genPresetContent() {
  return `
  #include <stdio.h>
  #include <stdlib.h>
  #define STACK_LIMIT 1000
  #define SYMBOL_CHART_LIMIT 1000
  #define SYMBOL_REC_LIMIT 1000
  struct SymbolChartCell {
    char *name;
    char *value;
  };
  int stateStack[STACK_LIMIT];
  int stateStackSize = 0;
  char *symbolRec[SYMBOL_REC_LIMIT];
  int symbolRecSize = 0;
  SymbolChartCell symbolChart[SYMBOL_CHART_LIMIT];
  int symbolChartSize = 0;
  `
}


